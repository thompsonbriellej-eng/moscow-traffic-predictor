<!-- DROP THIS SCRIPT SNIPPET INTO YOUR PAGE (replace old predict helpers) -->
<script>
// --- helpers for accuracy improvements ---

// EWMA: keep running smoothing of raw congestion in localStorage
function ewmaStoreKey() { return 'mt_ewma_v1'; }
function pushRawToHistory(raw) {
  const H = JSON.parse(localStorage.getItem('mt_raw_hist_v1')||'[]');
  H.unshift({t:Date.now(), raw: Number(raw)});
  localStorage.setItem('mt_raw_hist_v1', JSON.stringify(H.slice(0,200))); // keep 200 points
}
function readRawHistory() {
  return JSON.parse(localStorage.getItem('mt_raw_hist_v1')||'[]');
}
function updateEWMA(raw, alpha=0.25) {
  let ewma = Number(localStorage.getItem(ewmaStoreKey()) || 0);
  if(!ewma || ewma===0) ewma = raw;
  else ewma = alpha * raw + (1-alpha) * ewma;
  localStorage.setItem(ewmaStoreKey(), String(ewma));
  return ewma;
}

// Simple holiday heuristic (country-level quick table) - extend later
const HOLIDAYS_SIMPLE = {
  'Russia': ['01-01','01-07','05-01','05-09','06-12'], // mm-dd
  'United States': ['01-01','07-04','12-25'],
  'United Kingdom': ['01-01','12-25']
};
function isHoliday(country, date=new Date()) {
  try {
    const mmdd = (date.getMonth()+1).toString().padStart(2,'0') + '-' + date.getDate().toString().padStart(2,'0');
    return (HOLIDAYS_SIMPLE[country]||[]).includes(mmdd);
  } catch(e) { return false; }
}

// Robust confidence heuristic based on history and weather availability
function calcConfidence(baseScore, rawHistory, weather) {
  // rawHistory: array of {t,raw}
  let conf = 60;
  if(rawHistory.length>10) {
    // compute short-term stability (stddev of last 10)
    const last = rawHistory.slice(0,10).map(x=>x.raw);
    const mean = last.reduce((a,b)=>a+b,0)/last.length;
    const variance = last.reduce((a,b)=>a+Math.pow(b-mean,2),0)/last.length;
    const std = Math.sqrt(variance);
    // more stable -> higher confidence
    conf += Math.max(0, 15 - std*3); // tuned
  } else conf -= 10; // little history => less confidence

  if(!weather) conf -= 10;
  if(baseScore > 8 || baseScore < 2) conf -= 4; // extreme predictions slightly less confident
  conf = Math.max(20, Math.min(98, Math.round(conf)));
  return conf;
}

// tuned multipliers (you will refine from data)
const WEATHER_MULT = {precip_small: 0.9, precip_med: 1.4, precip_large: 2.2, snow: 2.5, wind_high: 0.6};
const WEEKDAY_BASE = {0: -0.4, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 0.8, 6: -0.2};

// improved scoring function
async function improvedPredict(useDemo=false) {
  // UI state
  predictBtn.disabled = true; predictBtn.innerText = 'Predicting... (improved)';
  try {
    // 1) raw congestion — try to use real source when available, else fallback to estimated placeholder
    // NOTE: when you add server proxy, replace this section with fetch('/api/proxy/traffic?city=...')
    let raw = useDemo ? (3 + Math.random()*5) : (3 + Math.random()*5);
    // store raw
    pushRawToHistory(raw);

    // 2) get smoothed baseline from EWMA
    const ewma = updateEWMA(raw, 0.28);

    // 3) weather (if available) - same logic as your fetchWeatherFor
    const country = countrySelect.value;
    const cityId = citySelect.value;
    const cityObj = (CITY_DB[country]||[]).find(c=>c.id===cityId);
    let weather = null;
    if(!useDemo && cityObj) {
      try { weather = await fetchWeatherFor(cityObj.lat, cityObj.lon); }
      catch(e){ weather = null; }
    }

    // 4) compose features & tuned weights
    let base = Number(ewma); // start from smoothed raw
    // weather adjustments
    if(weather) {
      if(weather.precipitation > 2.0) base += WEATHER_MULT.precip_large;
      else if(weather.precipitation > 0.5) base += WEATHER_MULT.precip_med;
      else if(weather.precipitation > 0.05) base += WEATHER_MULT.precip_small;
      if(weather.snowfall > 0.05) base += WEATHER_MULT.snow;
      if(weather.windspeed > 12) base += WEATHER_MULT.wind_high;
    }
    // weekday/time bias (we predict morning always so weekday matters)
    const tomorrow = new Date(Date.now() + 24*60*60*1000);
    const dow = tomorrow.getDay();
    base += (WEEKDAY_BASE[dow] || 0);

    // route factor (if a specific route is specified we slightly bump)
    const route = routeInput.value.trim();
    if(route) base += Math.min(1.2, (route.length > 2 ? 1.0 : 0.4));

    // holiday reduces commute in many locales
    if(isHoliday(country, tomorrow)) base -= 1.7;

    // clamp
    base = Math.max(0, Math.min(10, base));

    // anomaly check: if latest raw deviates a lot from EWMA, reduce confidence & nudge score toward ewma
    const rawHist = readRawHistory();
    if(rawHist.length > 5) {
      const recentAvg = rawHist.slice(0,5).reduce((s,x)=>s+x.raw,0)/5;
      if(Math.abs(raw - recentAvg) > 3.0) {
        base = (base + recentAvg) / 2; // pull toward recent average
      }
    }

    // label + confidence
    const label = base < 3.5 ? 'Low' : (base >= 6.5 ? 'High' : 'Medium');
    const confidence = calcConfidence(base, rawHist, weather);

    // update UI
    predLabel.innerText = label === 'Low' ? 'Light congestion expected' : label === 'Medium' ? 'Moderate congestion expected' : 'Heavy congestion expected';
    scoreEl.innerText = Math.round(base*10)/10;
    confEl.innerText = confidence;
    colorifyBadge(label);

    explainEl.innerText = `Smoothed:${ewma.toFixed(2)} · raw:${raw.toFixed(1)} · precip:${(weather?.precipitation||0).toFixed(2)}mm · snow:${(weather?.snowfall||0).toFixed(2)}mm`;
    rawCong.innerText = raw.toFixed(1);
    rawTime.innerText = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});

    // store prediction in history for later model training
    pushHistory({time: new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}), country: country, place: cityObj ? cityObj.name : '-', route: route, label: label, score: Math.round(base*10)/10, conf: confidence, raw: raw, ewma: ewma});
  } catch(e) {
    console.error('improvedPredict error', e);
    alert('Prediction failed — check console');
  } finally {
    predictBtn.disabled = false;
    predictBtn.innerText = 'Predict Morning Rush';
  }
}

// Replace event handler to use improvedPredict
predictBtn.removeEventListener('click', ()=>predict(false));
predictBtn.addEventListener('click', ()=>improvedPredict(false));
demoBtn.removeEventListener('click', ()=>predict(true));
demoBtn.addEventListener('click', ()=>improvedPredict(true));

</script>
